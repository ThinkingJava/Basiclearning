# 建堆操作

## 方式1：从倒数第一个父类节点开始调整

```java
/**
 * 堆--大顶堆满足条件
 *  a[i]>=a[2*i+1] a[i]>=a[2*i+2]
 * @param arr
 */
public static void  buildHeap(int arr[]){
    int size = arr.length;
    //第一个父类节点
    int firstIndex = (size-1)/2;
    // 按照完全二叉树的特点，从最后一个非叶子节点开始，对于整棵树进行大根堆的调整
    // 也就是说，是按照自下而上，每一层都是自右向左来进行调整的
    // 注意，这里元素的索引是从0开始的
    // 另一件需要注意的事情，这里的建堆，是用堆调整的方式来做的
    // 堆调整的逻辑在建堆和后续排序过程中复用的
    for(int i= firstIndex;i>=0;i--){
        // 可以参照sort中的调用逻辑，在堆建成，且完成第一次交换之后，实质上i=0；也就是说，是从根所在的最小子树开始调整的
        // 接下来的讲解，都是按照i的初始值为0来讲述的
        // 这一段很好理解，如果i=0；则k=1；k+1=2
        // 实质上，就是根节点和其左右子节点记性比较，让k指向这个不超过三个节点的子树中最大的值
        // 这里，必须要说下为什么k值是跳跃性的。
        // 首先，举个例子，如果a[0] > a[1]&&a[0]>a[2],说明0,1,2这棵树不需要调整，那么，下一步该到哪个节点了呢？肯定是a[1]所在的子树了，
        // 也就是说，是以本节点的左子节点为根的那棵小的子树
        // 而如果a[0}<a[2]呢，那就调整a[0]和a[2]的位置，然后继续调整以a[2]为根节点的那棵子树，而且肯定是从左子树开始调整的
        // 所以，这里面的用意就在于，自上而下，自左向右一点点调整整棵树的部分，直到每一颗小子树都满足大根堆的规律为止
         for(int j = 2*i+1;j<size;j=2*j+1){
             // 让k先指向子节点中最大的节点
             if(j+1<size&&arr[j]<arr[j+1]){
                 j++;
             }
             // 如果发现子节点更大，则进行值的交换
            if(arr[j]>arr[i]){
                 swap(arr,j,i);
                 if(j<firstIndex) {
                     // 下面就是非常关键的一步了
                     // 如果子节点更换了，那么，以子节点为根的子树会不会受到影响呢？
                     // 所以，循环对子节点所在的树继续进行判断
                     i = j;
                 }
            }else{
                // 如果不用交换，那么，就直接终止循环了
                 break;
            }
         }

    }
}
```

## 方式2：从第一个节点开始

```java
//自下而上
public static void buildHeap(int[] arr){
    int size = arr.length;
    //从最后一个节点遍历，对整棵树进行大根堆的调整
    //也就是说，是按照自下而上，每一层都是自左向右来进行调整的
    for(int i=0;i<size;i++){
        int currentIndex = i;
        int fatherIndex = (i-1)/2;
        // 堆调整的逻辑在建堆和后续排序过程中复用的
        while(arr[currentIndex]>arr[fatherIndex]){
            swap(arr,currentIndex,fatherIndex);
            currentIndex = fatherIndex;
            fatherIndex = (fatherIndex-1)/2;
        }
    }
}
```

